function add(a: int; b: int) returns (c: int);
let  
  c = a + b;
tel
type Color = enum {Red, Blue, Green, Yellow, Orange, Purple};


function complement_color(c: Color) returns (comp: Color);
(*@contract
  guarantee "forall c, c != comp" c = comp => false;
*)

let
    comp = 
        if c = Red then Green
        else if c = Green then Red
        else if c = Blue then Orange
        else if c = Orange then Blue
        else if c = Yellow then Purple
        else Yellow; 
tel

function complement_colors(arr: Color^5) returns (result: Color^5);
let 
  result = [complement_color(arr[0]),
            complement_color(arr[1]),
            complement_color(arr[2]),
            complement_color(arr[3]),
            complement_color(arr[4])];
tel

type Vector = struct {x: int; y: int; z: int};

function reflect_xy_plane(p: Vector) returns (r: Vector);
(*@contract
  guarantee "forall p: p.x = r.x" p.x = r.x;
  guarantee "forall p: p.y = r.y" p.y = r.y;
  guarantee "forall p: p.z = -r.z" p.z = -r.z;
*)

let

  r = Vector {x = p.x; y = p.y; z = -p.z};

tel


type Particle = struct {pos : Vector; vel: Vector};

function turn_around(init: Particle) returns (post: Particle);
(*@contract
    guarantee "position invariant" init.pos = post.pos;
    guarantee "velocity x flipped" init.vel.x = -post.vel.x;
    guarantee "velocity y flipped" init.vel.y = -post.vel.y;
    guarantee "velocity z flipped" init.vel.z = -post.vel.z;
*)
let 
  post = Particle { pos = init.pos; vel = Vector {x = -init.vel.x;y = -init.vel.y ;z = -init.vel.z;}};
tel



function increment_pos_1(arr: int^10) returns (result: int^10);
let 
  -- result = [arr[0] , arr[1] + 1, arr[2]];
tel

function id(arr: int^5) returns (result: int^5);
let 
  result = arr;
tel

